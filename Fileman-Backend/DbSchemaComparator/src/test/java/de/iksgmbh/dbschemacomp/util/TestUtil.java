package de.iksgmbh.dbschemacomp.util;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;

public class TestUtil 
{
	public static String readSchema(String filename) 
	{
	       StringBuilder contentBuilder = new StringBuilder();
	       
	        try (Stream<String> stream = Files.lines( Paths.get(filename), StandardCharsets.UTF_8)) 
	        {
	            stream.forEach(s -> contentBuilder.append(s).append("\n"));
	        }
	        catch (IOException e) 
	        {
	            e.printStackTrace();
	        }
	 
	        return contentBuilder.toString();
	}	
	
	public static String getDatabaseSchema(JdbcTemplate template) throws IOException {
		
		List<String> outputSqlRows = new ArrayList<String>();
		
		SqlRowSet tableNames = template.queryForRowSet(
				"SELECT table_name FROM INFORMATION_SCHEMA.TABLES "
				+ "where sql is not null order by id;");
		
		while (tableNames.next()) {
			
			String tableName = tableNames.getString("table_name");
			
			SqlRowSet columns = template.queryForRowSet(
					"SELECT column_name, column_type "
					+ "FROM INFORMATION_SCHEMA.COLUMNS "
					+ "where table_schema = 'PUBLIC' "
					+ "and table_name = '" + tableName + "' "
					+ "order by ordinal_position;");
			
			String createTableRow = "create table " + tableName + " (";
			boolean firstColumn = true;
			
			while (columns.next()) {

				String columnName = columns.getString("column_name");
				String columnType = columns.getString("column_type").toLowerCase();
				
				if (firstColumn) {
					firstColumn = false;
				} else {
					createTableRow += ", ";
				}
				
				createTableRow += columnName+" "+columnType;
			}
			
			SqlRowSet primaryKey = template.queryForRowSet(
					"SELECT column_list FROM INFORMATION_SCHEMA.CONSTRAINTS "
					+ "where constraint_type = 'PRIMARY KEY' "
					+ "and table_name = '" + tableName + "';");
			
			if (primaryKey.next()) {
				createTableRow += ", primary key (" 
						+ primaryKey.getString("column_list") + ")";
			}
			
			createTableRow += ");";
			
			createTableRow = replaceDynamicSubstring(createTableRow, 
					"default next value for \"public\".\"system_sequence_",
					"\" ", "generated by default as identity");
			
			createTableRow = replaceDynamicSubstring(createTableRow, 
					"not null null_to_default sequence \"public\".\"system_sequence_",
					"\"", "");
			
			outputSqlRows.add(createTableRow);
		}
		
		SqlRowSet uniqueConstraints = template.queryForRowSet("SELECT constraint_name, table_name, column_list "
																+ "FROM INFORMATION_SCHEMA.CONSTRAINTS "
																+ "where constraint_type = 'UNIQUE'");
		
		while (uniqueConstraints.next()) 
		{
			String constraintName = uniqueConstraints.getString("constraint_name");
			String tableName = uniqueConstraints.getString("table_name");
			String columnList = uniqueConstraints.getString("column_list");

			String addUniqueConstraintRow = "alter table " + tableName + " add constraint "
					                         + constraintName + " unique (" + columnList + ");\n";
			outputSqlRows.add(addUniqueConstraintRow);
		}
		
		
		StringBuffer toReturn  = new StringBuffer();
		for (String outputSqlRow: outputSqlRows) {
			toReturn.append(outputSqlRow).append(System.getProperty("line.separator"));
        }
		
		return toReturn.toString().trim();
	}

	private static String replaceDynamicSubstring(String fullOriginalString, 
			                               String replaceFrom, 
			                               String replaceTo, 
			                               String replacement) 
	{
		if (fullOriginalString.contains(replaceFrom)) 
		{
			int beginIndex = fullOriginalString.indexOf(replaceFrom);
			int endIndex = fullOriginalString.indexOf(replaceTo, beginIndex + replaceFrom.length());
			String substringToReplace = fullOriginalString.substring(beginIndex, endIndex + replaceTo.length());
			return fullOriginalString.replace(substringToReplace, replacement);
		}
		return fullOriginalString;
	}
	
	public static String sortStatements(String statementList) 
	{
		String[] splitResult = statementList.split(System.getProperty("line.separator"));
		List<String> list = Arrays.asList(splitResult);
		java.util.Collections.sort(list);
		StringBuffer sb = new StringBuffer();
		list.forEach(statement -> sb.append(statement).append(System.getProperty("line.separator")));
		return sb.toString().trim();
	}
	
}
